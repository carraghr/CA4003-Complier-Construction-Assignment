/****************************************************
*
*	Section 1 - Options
*
*****************************************************/

options{ JAVA_UNICODE_ESCAPE = true; }
/****************************************************
*
*	Section 2 - User Code
*
*****************************************************/

PARSER_BEGIN(BasicLTokeniser)

public class BasicLTokeniser{

  	//Parser executions
	public static void main(String [] args){

		//Parser initialisationz
		BasicLTokeniser tokeniser;

		if(args.length == 0){
			System.out.println("Reading from standard input ...");
			tokeniser = new BasicLTokeniser(System.in);
		}
		else if(args.length == 1){
		  try{
			tokeniser = new BasicLTokeniser(new java.io.FileInputStream(args[0]));
		  }catch(java.io.FileNotFoundException e){
		    System.err.println("File " + args[0] + " not found");
		    return;
		  }
		}
		else{
		  System.out.println("BasicL Tokeniser: Usage is one of:");
		  System.out.println("java BasicLTokeniser < inputfile");
		  System.out.println("OR");
		  System.out.println("java BasicLTokeniser inputfile");
		  return;
		}

		for(Token t = getNextToken(); t.kind!=EOF; t = getNextToken()){
		  if(t.kind == NUM){
		    System.out.println("Number");
		    System.out.println("("+t.image+") ");
		  }
		  else if(t.kind == ID){
		    System.out.println("Identifier");
		    System.out.println("("+t.image+") ");
		  }
		  else if(t.kind == AND){
		    System.out.println("LETTER");
		    System.out.println("("+t.image+") ");
		  }
		}
	}
}
PARSER_END(BasicLTokeniser)
/****************************************************
*
*	Section 3 - Token Definitions
*
*****************************************************/
TOKEN_MGR_DECLS : {
  static int commentNesting = 0;
}
TOKEN : {
    < EMPTY : "" >
    : MATCH_NON_EMPTY // change state, or infinite matches of the empty string could result
}

<MATCH_NON_EMPTY>
TOKEN : {
    < NON_EMPTY : ~[] >
}

SKIP : {  " " //Ignoring spaces/tabs/new lines
		| "\t"
		| "\n"
		| "\r"
		| "\f"
}
SKIP : { /* comments */
		"/*"{commentNesting++;}:IN_COMMENT
		|< "--" (~["\r", "\n"])* > //~["\n","\r"] matches any character except the new line characters}
<IN_COMMENT> SKIP : { "/*" { commentNesting++; }					| "*/" { commentNesting--;
		  		 			 if(commentNesting == 0)								SwitchTo(DEFAULT); //stops reading in a comment Allows for in line comments 			   			   }					|< ~[] > //takes any character}
TOKEN :{ < AND : "and" > /*Keywords*/  		| < BOOL : "bool" >
  		| < CONST : "const" >
  		| < DO : "do">
  		| < ELSE : "else" >
  		| < FALSE : "false">
  		| < IF : "if">
  		| < INT : "int">
  		| < MAIN : "main">
  		| < NOT :"not">
  		| < OR : "or">
  		| < RETURN : "return">
  		| < THEN : "then">
  		| < TRUE : "true">
  		| < VAR : "var">
  		| < VOID : "void">
  		| < WHILE : "while">
  		| < BEGIN : "begin">
  		| < END : "end">
  }

TOKEN : { < NUM : (< DIGIT>)+ > /* numbers and Identifiers */
		| < #DIGIT : ["0" - "9"] >
		| < ID : < LETTER > (["a"-"z","A"-"Z","0"-"9","_"])*>//letter first then letter|digit| underscore   		| < #LETTER : ["a" - "z","A" - "Z"] >
}

TOKEN : { <PLUS_SIGN :"+"> /*Operators and relations*/
		| < MINUS_SIGN :"-">
		| < MULT_SIGN : "*">
		| < DIV_SIGN : "/">
		| < EQUALS_SIGN : "=">
		| < NOT_EQUALS_SIGN :"!=">
		| < LESS_THEN : "<">
		| < MORE_THEN : ">">
		| < LESS_THEN_EQ : "<=">
		| < MORE_THEN_EQ : ">=">
		| < LBR : "(">
		| < RBR : ")">
		| < COMMA : ",">
		| < SEMI_COLON : ";">
		| < COLON : ":">
		| < ASSIGN : ":=">
}

TOKEN : { < OTHER : ~[]> }/* Anything that is not recognised so far.*/

/****************************************************
*
*	Section 4 - The Grammar
*
*****************************************************/

void program() : {}
				 {
				   decl()
				   function()
				   main_prog()				 }

void decl() :	{}
				{
				  decl_type() decl()
				|{}
				}

void decl_type() : {}
				 {
				  var_decl()
				 |const_decl()				 }

void var_decl() : {}
				{
				  <VAR> ident_list() <COLON> type() var_group_decl() <SEMI_COLON>
				}
				
void var_group_decl() : {}
					   {
					     <COMMA> ident_list() <COLON> type() var_group_decl()
					     |{}
					   }

void const_decl() :	{}
					{
					  <CONST> <ID> <COLON> type() <EQUALS_SIGN> expression() const_group_decl() <SEMI_COLON>
					}

void const_group_decl() : {}
						{
						  <COMMA> <ID> <COLON> type() <EQUALS_SIGN> expression() const_group_decl()
						|{}						}

void function() : {}
				  {
				    type() <ID> <LBR> param_list() <RBR>
				    <BEGIN>
				    decl()
				    continuous_statements()
				    <RETURN> return_type() <SEMI_COLON>
				    <END> function()
				  |{}
				  }

void return_type() :{}
					{
					  expression()
					  |{}					}

void param_list() :	{}
					{
					  <ID> <COLON> type() param_list_grouped()
					  |{}					}

void param_list_grouped() : {}
							{
							  <COMMA> <ID> <COLON> type() param_list_grouped()
							| {}							}

void type() : {}
			{
			  <INT> | <BOOL> | <VOID>
			}

void main_prog() : {}
				   {
				     <MAIN>
				     <BEGIN>
				     decl()
				     continuous_statements()
				     <END>
				   }

void statement() : {}
				   {
					  <ID> <ASSIGN> expression()
					| <ID> <LBR> arg_list() <RBR>
					| <BEGIN> (statement() <SEMI_COLON> )* <END>
					| <IF> conditon() <THEN> statement() <ELSE> statement()
					| <WHILE> conditon() <DO> statement()
					| {}
				   }
				   
void continuous_statements() : {}
								{
								  statement() <SEMI_COLON> continuous_statements()								| {}								}

void expression() :	{}
					{
					  fragment() expression_right_side() /*an expression is one or more */
					 |expression() expression_right_side()
					 |<LBR>expression()<RBR> /* (function call or some maths to be done)*/
					 |<ID> <LBR> arg_list() <RBR> /* Function call*/
					}

void expression_right_side () : {}
								{
								 operator() fragment() expression_right_side()
								|{}
								}

void operator() : {}
				   {
				   	 <PLUS_SIGN >
				   | < MINUS_SIGN >
				   | < MULT_SIGN>
				   | < DIV_SIGN>				   }

void fragment() : {}
				  {
				     <ID>
				   | <TRUE>
				   | <FALSE>
				   | <NUM>
				   | side_of_zero() value_or_expression()
				  }

void value_or_expression(): {}
							{
							  fragment() /* This void method leads to ambiguaty */
							| expression()
							}

void side_of_zero() : {}
					  {
					    <PLUS_SIGN>
					   |< MINUS_SIGN>					  }					  

void conditon() : {}
				   {
				     <NOT> expression()
				   	| expression() (<EQUALS_SIGN>|<NOT_EQUALS_SIGN>|<LESS_THEN>|<MORE_THEN>|<LESS_THEN_EQ>|<MORE_THEN_EQ>) expression()
				   	| conditon() (<AND>|<OR>) conditon()
				   	| <ID>				   }

void ident_list() : {}
				 {
				   <ID> (<COMMA> <ID>)* 
				 }

void arg_list() : {}
				{
				   (ident_list()|<EMPTY>)
				}
/*
expression ::= term expressionPrime

expressionPrime ::= + expression
				| - expression
				| {}

term ::= factor termPrime

termPrime ::= * term
			| / term
			| {}

factor ::= number
		| id

*/






